name: Build and Publish NuGet Packages

on:
  push:
    branches: [ main, next ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  DOTNET_VERSION: '8.0.x'
  DOTNET_NOLOGO: true
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true

jobs:
  build:
    runs-on: ubuntu-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Full history for versioning
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Calculate version
      id: version
      run: |
        # Get the latest tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        # Extract version number (remove 'v' prefix)
        VERSION=${LATEST_TAG#v}
        
        # Split version into parts
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]:-0}
        
        # Determine if this is a prerelease build
        IS_PRERELEASE="false"
        if [ "${{ github.ref }}" = "refs/heads/next" ]; then
          IS_PRERELEASE="true"
          # For next branch, increment minor version and add prerelease suffix
          NEW_MAJOR=$MAJOR
          NEW_MINOR=$((MINOR + 1))
          NEW_PATCH=0
          
          # Generate prerelease identifier with commit hash
          COMMIT_HASH=$(git rev-parse --short HEAD)
          BUILD_NUMBER=${{ github.run_number }}
          PRERELEASE_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH-preview.$BUILD_NUMBER+$COMMIT_HASH"
          
          echo "version=$PRERELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
          echo "Prerelease version: $PRERELEASE_VERSION"
        else
          # For main branch or tags, use standard versioning
          NEW_MAJOR=$MAJOR
          NEW_MINOR=$MINOR
          NEW_PATCH=$((PATCH + 1))
          
          RELEASE_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
          
          echo "version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
          echo "Release version: $RELEASE_VERSION"
        fi
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build solution
      run: dotnet build --configuration Release --no-restore
    
    - name: Run tests
      run: dotnet test --configuration Release --no-build --verbosity normal
    
    - name: Pack CanonicaLib.DataAnnotations
      run: |
        dotnet pack CanonicaLib.DataAnnotations/CanonicaLib.DataAnnotations.csproj \
          --configuration Release \
          --no-build \
          --output ./packages \
          -p:PackageVersion=${{ steps.version.outputs.version }}
    
    - name: Pack CanonicaLib.UI
      run: |
        dotnet pack CanonicaLib.UI/CanonicaLib.UI.csproj \
          --configuration Release \
          --no-build \
          --output ./packages \
          -p:PackageVersion=${{ steps.version.outputs.version }}
    
    - name: Upload packages as artifacts
      uses: actions/upload-artifact@v4
      with:
        name: nuget-packages-${{ github.run_id }}
        path: ./packages/*.nupkg

  publish-prerelease:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/next' && github.event_name == 'push'
    
    steps:
    - name: Download packages
      uses: actions/download-artifact@v4
      with:
        name: nuget-packages-${{ github.run_id }}
        path: ./packages
    
    - name: Publish prerelease to NuGet.org
      run: |
        echo "Publishing prerelease packages version ${{ needs.build.outputs.version }}"
        dotnet nuget push ./packages/*.nupkg \
          --api-key ${{ secrets.NUGET_API_KEY }} \
          --source https://api.nuget.org/v3/index.json \
          --skip-duplicate

  release:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Download packages
      uses: actions/download-artifact@v4
      with:
        name: nuget-packages-${{ github.ref_name }}
        path: ./packages
    
    - name: Calculate next version for tagging
      id: next_version
      run: |
        # Get the latest tag
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $LATEST_TAG"
        
        # Extract version number (remove 'v' prefix)
        VERSION=${LATEST_TAG#v}
        
        # Split version into parts
        IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
        MAJOR=${VERSION_PARTS[0]}
        MINOR=${VERSION_PARTS[1]}
        PATCH=${VERSION_PARTS[2]:-0}
        
        # Determine version bump based on commit messages since last tag
        COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s" 2>/dev/null || git log --pretty=format:"%s")
        
        # Default to patch increment
        NEW_MAJOR=$MAJOR
        NEW_MINOR=$MINOR
        NEW_PATCH=$((PATCH + 1))
        
        # Check for breaking changes or major features
        if echo "$COMMITS" | grep -i "BREAKING CHANGE\|breaking:" >/dev/null; then
          NEW_MAJOR=$((MAJOR + 1))
          NEW_MINOR=0
          NEW_PATCH=0
        elif echo "$COMMITS" | grep -i "feat\|feature:" >/dev/null; then
          NEW_MINOR=$((MINOR + 1))
          NEW_PATCH=0
        fi
        
        NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
        NEW_TAG="v$NEW_VERSION"
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
        echo "Next version: $NEW_VERSION"
    
    - name: Create and push tag
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git tag ${{ steps.next_version.outputs.new_tag }}
        git push origin ${{ steps.next_version.outputs.new_tag }}
    
    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.next_version.outputs.new_tag }}
        release_name: Release ${{ steps.next_version.outputs.new_version }}
        draft: false
        prerelease: false
        body: |
          ## Changes in ${{ steps.next_version.outputs.new_version }}
          
          This release was automatically created from the main branch.
          
          ### Commits since last release:
          ${{ github.event.head_commit.message }}
    
    - name: Publish to NuGet.org
      run: |
        dotnet nuget push ./packages/*.nupkg \
          --api-key ${{ secrets.NUGET_API_KEY }} \
          --source https://api.nuget.org/v3/index.json \
          --skip-duplicate

  publish-tagged:
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
    
    - name: Restore dependencies
      run: dotnet restore
    
    - name: Build solution
      run: dotnet build --configuration Release --no-restore
    
    - name: Run tests
      run: dotnet test --configuration Release --no-build --verbosity normal
    
    - name: Pack CanonicaLib.DataAnnotations
      run: dotnet pack CanonicaLib.DataAnnotations/CanonicaLib.DataAnnotations.csproj --configuration Release --no-build --output ./packages
    
    - name: Pack CanonicaLib.UI
      run: dotnet pack CanonicaLib.UI/CanonicaLib.UI.csproj --configuration Release --no-build --output ./packages
    
    - name: Publish to NuGet.org (manual tag)
      run: |
        dotnet nuget push ./packages/*.nupkg \
          --api-key ${{ secrets.NUGET_API_KEY }} \
          --source https://api.nuget.org/v3/index.json \
          --skip-duplicate